import sys
import bio # codon (seq) library
from collections import Counter
from utils import *

## Install
#CODON
#/bin/bash -c "$(curl -fsSL https://exaloop.io/install.sh)"
#SEQ (assuming Codon is in $HOME/.codon)
#curl -L https://github.com/exaloop/seq/releases/download/v0.11.3/seq-$(uname -s | awk '{print tolower($0)}')-$(uname -m).tar.gz | tar zxvf - -C .codon/lib/codon/plugins

## Run script like this:
# codon run -plugin seq -release -D BC_LEN=16 -D BC_START=29 -D MIN_READS_IN_BC=200 01_divmux.codon <Path_I1_gzipped_or_not> <Path_R1_unzipped> <Path_R2_unzipped> <Path_whitelist> <Path_output_stats.tsv> <Path_reads_per_barcode_stats.tsv> <Hamming_distance_allowed>
# e.g.:
# codon run -plugin seq -release -D BC_LEN=16 -D BC_START=29 -D MIN_READS_IN_BC=20 01_divmux.codon I1.fq R1.fq R2.fq whitelist.txt demux_stats.tsv reads_per_barcode.tsv 1

# Build exec with: (not very useful as exec still need to be run with codon)
# codon build -plugin seq -release -exe -D BC_LEN=16 -D BC_START=29 -D MIN_READS_IN_BC=200 01_divmux.codon
# 01_divmux ScKDMA_S1_R2_001.fastq.gz ScKDMA_S1_R1_001.fastq ScKDMA_S1_R2_001.fastq whitelist_10xATAC_737K-cratac-v1.txt ScKDMA_S1_BC_stats.tsv ScKDMA_S1_reads_per_barcode.tsv 2

## Default values
# BC_LEN and BC_START MIN_READS_IN_BC need to be passed when invoking codon: 
# "codon run -plugin seq -release -D BC_LEN=16 -D BC_START=29 -D MIN_READS_IN_BC=200 divmux.codon ..."

# Minimum percentage of barcodes that should be found before returning with an error.
min_frac_bcs_to_find_default = 0.5

# By default we reverse-complement the BC read (I1)
# If we find less than 50% matching bcs then we reperform
# the correction with rev_comp set to False
rev_comp = True

## Functions
def read_barcode_whitelist_from_file(
    bc_whitelist_filename: str,
    bc_length_i: Static[int]
):
    """
    Read whitelisted barcodes from file and convert to a set of Kmers.
    Parameters
    ----------
    bc_whitelist_filename
        Filename with whitelisted barcodes.
    bc_length_i
        Length of barcode.
    Returns
    -------
    Set with barcodes as Kmers.
    """
    sys.stdout.write(f"Importing whitelist: {bc_whitelist_filename}\n")
    bc_whitelist = set()
    with open(bc_whitelist_filename, "r") as fh:
        [bc_whitelist.add(Kmer[bc_length_i](seq(bc_line.strip()))) for bc_line in fh]
    return bc_whitelist

def correct_barcodes_from_fastq(
    R1:str,
    I1:str,
    R2:str,
    start_pos_bc: Static[int],
    bc_length_i: Static[int],
    nanoCT_singlecell_bc_whitelist: set[Kmer[BC_LEN]],
    corrected_bc_stats_tsv_filename: str,
    reads_per_barcode_tsv_filename: str,
    max_hamming_dist: int,
    rev_comp: bool
) -> float:
    """
    Read nanoCT artifical BC FASTQ with 16bp cell barcode
    Add corrected BCs to R1 R2 FASTQs

    Parameters
    ----------
    nanoCT_singlecell_bc_whitelist:
        File with 16bp cell barcode whitelist
    R1 & R2:
        Input FASTQ files with normal reads
    I1:
        Input FASTQ.GZ file with raw barcode reads, made from:
          - 16bp cell barcode 29-45
          (- 8bp modality barcode 0-8)
    corrected_bc_stats_tsv_filename:
        File with barcode correction statistics.
    max_hamming_dist:
        Maximum hamming distance allowed for the barcode to consider it a match with
        the whitelist. Default: 1.
    rev_comp:
        Whether to take the Reverse Complement of the BC in I1 before checking the WL.

    Returns
    -------
    frac_bcs_found

    """

    # Store all reads of R1 and R2
    sys.stdout.write("Importing R1, R2\n")
    with open(R1, 'r') as R1_fh, open(R2, 'r') as R2_fh:
        R1_lines = R1_fh.readlines()
        sys.stdout.write(f"R1: {len(R1_lines)//4} reads\n")
        R2_lines = R2_fh.readlines()
        sys.stdout.write(f"R2: {len(R2_lines)//4} reads\n")
    
    sys.stdout.write("I1 Barcode correction...\n")
    # Store number of reads in FASTQ file.
    total_reads = 0
    # Store number of reads which have hamming distance of 0, 1, 2 or 3 from barcodes whitelist.
    bc_mismatches_stats = [0, 0, 0, 0]
    # Get total number of reads
    len_record = len(R1_lines)//4
    # Get the size of a 1000th of the read number
    prog_100th = len_record//100
    # Initialize Barcode and quality lists
    corr_bcs = List[str](capacity=len_record)
    seq_bcs = List[str](capacity=len_record)
    qual_bcs = List[str](capacity=len_record)

    for record in bio.FASTQ(I1, gzip=True, validate=False, copy=True):
        # Tally processed reads
        total_reads += 1

        # Output progress
        if total_reads % prog_100th == 0:
            sys.stdout.write(f"\r{int(100*total_reads/len_record)}%")
            sys.stdout.flush()
        if total_reads == len_record:
            sys.stdout.write("\r")
            sys.stdout.flush()

        # Get barcode sequence and associated quality from FASTQ record
        if rev_comp:
            # reverse complemented
            bc_seq, bc_qual = ((~(record.seq[start_pos_bc:start_pos_bc+bc_length_i]), record.qual[start_pos_bc:start_pos_bc+bc_length_i][::-1]))
        else:
            # Forward
            bc_seq, bc_qual = (record.seq[start_pos_bc:start_pos_bc+bc_length_i], record.qual[start_pos_bc:start_pos_bc+bc_length_i])

        # Store the original sequence and quality 
        seq_bcs.append(str(bc_seq))
        qual_bcs.append(bc_qual)

        # Get the corrected bc (even HD=0)
        corrected_bc = correct_bc_by_qual_order_with_whitelist_or_correct_bc_with_Ns_with_whitelist(
            bc_whitelist=nanoCT_singlecell_bc_whitelist,
            bc_length_e=bc_length_i,
            bc_seq=bc_seq,
            bc_qual=bc_qual,
            max_hamming_dist=max_hamming_dist,
        )

        #If BC found store it, otherwise store NoMatch
        if corrected_bc:
            bc_mismatches_stats[corrected_bc.hamming_dist] += 1
            corr_bcs.append(corrected_bc.corrected_bc)
        else:
            corr_bcs.append('NoMatch')
    
    #sys.stdout.write("Read Filtering based on matching barcode and min number of reads per barcode...\n")
    #sys.stdout.write("Calculate reads per barcode...\n")
    BC_Counter = Counter(corr_bcs)
    passing_BCs_indices = [index for index, item in enumerate(corr_bcs) if item != 'NoMatch' and BC_Counter[item] >= MIN_READS_IN_BC]
    passing_Reads_indices = [x*4 + y for x in passing_BCs_indices for y in range(4)]
    
    sys.stdout.write(f"Keep only barcodes containing {MIN_READS_IN_BC} reads or more...\n")
    R1_lines = [R1_lines[i] for i in passing_Reads_indices]
    R2_lines = [R2_lines[i] for i in passing_Reads_indices]
    
    qual_bcs = [qual_bcs[i] for i in passing_BCs_indices]
    seq_bcs = [seq_bcs[i] for i in passing_BCs_indices]
    corr_bcs = [corr_bcs[i] for i in passing_BCs_indices]
        
    # Modify R1,R2 read names, adds CB tag if BC found at max distance
    sys.stdout.write("Modifying R1, R2 read names...\n")
    reads_in_cells = 0
    len_record = len(R1_lines)//4
    
    for i in range(0, len(R1_lines), 4):
        # Tally processed reads
        reads_in_cells += 1
        # Output progress
        if reads_in_cells % prog_100th == 0:
            sys.stdout.write(f"\r{int(100*reads_in_cells/len_record)}%")
            sys.stdout.flush()
        if reads_in_cells == len_record:
            sys.stdout.write("\r")
            sys.stdout.flush()

        R1_lines[i] = R1_lines[i].split()[0] + f' CY:Z:{qual_bcs[i//4]}' + f'\tCR:Z:{seq_bcs[i//4]}' + f'\tCB:Z:{corr_bcs[i//4]}' + f'\tRG:Z:{corr_bcs[i//4]}' + '\n'
        R2_lines[i] = R2_lines[i].split()[0] + f' CY:Z:{qual_bcs[i//4]}' + f'\tCR:Z:{seq_bcs[i//4]}' + f'\tCB:Z:{corr_bcs[i//4]}' + f'\tRG:Z:{corr_bcs[i//4]}' + '\n'

    # Write new FASTQs for R1, R2
    sys.stdout.write("Writing corrected R1, R2 and log files\n\n")
    R1parts = R1.split('.')
    R2parts = R2.split('.')
    R1_corr = '.'.join(R1parts[:-1]) + '_correct' + '.' + R1parts[-1]
    R2_corr = '.'.join(R2parts[:-1]) + '_correct' + '.' + R2parts[-1]
    with open(R1_corr, 'w') as file:
        file.write(''.join(R1_lines))
    with open(R2_corr, 'w') as file:
        file.write(''.join(R2_lines))
    #open(R1_corr, 'w').write(''.join(R1_lines))
    #open(R2parts, 'w').write(''.join(R2_lines))

    # Calculate number of reads with/without a barcode.
    bc_reads = sum(bc_mismatches_stats)
    reads_without_bc = total_reads - bc_reads
    # Calculate fraction of barcodes found in all reads.
    frac_bcs_found = bc_reads / total_reads
    
    # Reads in barcode with less than required amount of reads
    reads_in_too_small_bc = bc_reads - reads_in_cells
    frac_reads_in_too_small_bc = reads_in_cells / bc_reads
    # Initialize an empty string variable to store the stats
    stats_tsv = ""

    # Append the stats
    stats_tsv += (
        f"reads\t{total_reads}\t100.00%\n" +
        f"bc_reads\t{bc_reads}\t" + f"{(bc_reads / total_reads * 100.0)}%\n" +
        f"reads_without_bc\t{reads_without_bc}\t" + f"{(reads_without_bc / total_reads * 100.0)}%\n"
    )
    for i in range(0, max_hamming_dist + 1):
        stats_tsv += (
            f"bc_reads_with_{i}_mismatches\t{bc_mismatches_stats[i]}\t" +
            f"{(bc_mismatches_stats[i] / total_reads * 100.0)}%\n"
        )
    stats_tsv += (
        f"bc_reads\t{bc_reads}\t" + f"{(bc_reads / total_reads * 100.0)}%\n" +
        f"bc_reads_in_cells\t{reads_in_cells}\t" + f"{(reads_in_cells / bc_reads * 100.0)}%\n" +
        f"bc_reads_in_too_small_bc\t{reads_in_too_small_bc}\t" + f"{(reads_in_too_small_bc / bc_reads * 100.0)}%\n"
        f"overall_passing_reads(valid_bc_and_cell)\t{reads_in_cells}\t" + f"{(reads_in_cells / total_reads * 100.0)}%\n"        
    )
    # write the stats to corrected_bc_stats_tsv_filename
    with open(corrected_bc_stats_tsv_filename, 'w') as corrected_bc_stats_tsv_fh:
        corrected_bc_stats_tsv_fh.write(stats_tsv)
    
    # write the reads_per_barcode to reads_per_barcode_tsv_filename
    with open(reads_per_barcode_tsv_filename, "w") as file:
        # Write item counts as tab-separated values
        for bc, read_count in BC_Counter.items():
            file.write(f"{read_count}\t{bc}\n")
    
    # print the stats 
    sys.stdout.write(f'\n{stats_tsv}\n')

    return frac_bcs_found


def main():
    # Check that the correct number of arguments are passed
    if not (isinstance(BC_LEN, int) and isinstance(BC_START, int) and isinstance(MIN_READS_IN_BC, int) and len(sys.argv) == 8):
        sys.stderr.write(
            f"Wrong call, exiting...\nUsage: codon run -plugin seq -release -D BC_LEN=<bc_length> -D BC_START=<start_pos_bc> -D MIN_READS_IN_BC=<min_reads_in_cells> {sys.argv[0]} I1.fastq.gz R1.fastq R2.fastq whitelist.txt output_stats.tsv output_read_per_barcode.tsv <max_hamming_dist>\n\n")
        sys.exit(1)
    else:
        I1 = sys.argv[1]
        R1 = sys.argv[2]
        R2 = sys.argv[3]
        nanoCT_singlecell_bc_whitelist_filename = sys.argv[4]
        corrected_bc_stats_tsv_filename = sys.argv[5]
        reads_per_barcode_tsv_filename = sys.argv[6]
        max_mismatches = int(sys.argv[7])
    # Check that the max_mismatches is 0, 1, 2 or 3
    if max_mismatches not in [0,1,2,3]:
        sys.stderr.write(f"\nExiting...\n<max_hamming_dist> must be 0, 1, 2 or 3\n")
        sys.exit(1)

    # Read cell barcodes from file and convert to a set of Kmers.
    nanoCT_singlecell_bc_whitelist = read_barcode_whitelist_from_file(
        bc_whitelist_filename=nanoCT_singlecell_bc_whitelist_filename,
        bc_length_i=BC_LEN)

    # Read FASTQ with barcodes and write R1 R2 FASTQs with corrected barcodes in CB comment for barcodes
    # that match the whitelist closely enough, else only write the original barcodes in CR.
    # Output the fraction of reads that have a barcode
    frac_bcs_found_rev = correct_barcodes_from_fastq(
        R1 = R1,
        I1 = I1,
        R2 = R2,
        start_pos_bc=BC_START,
        bc_length_i=BC_LEN,
        nanoCT_singlecell_bc_whitelist=nanoCT_singlecell_bc_whitelist,
        corrected_bc_stats_tsv_filename=corrected_bc_stats_tsv_filename,
        reads_per_barcode_tsv_filename=reads_per_barcode_tsv_filename,
        max_hamming_dist=max_mismatches,
        rev_comp=rev_comp)
    
    # If we find less than 50% matching bcs then we reperform
    # the correction with rev_comp set to False
    # and check again if we find more than 50% matching bcs
    # If not we exit with an error
    if frac_bcs_found_rev < min_frac_bcs_to_find_default:
        sys.stdout.write(f"Warning: Only {frac_bcs_found_rev * 100.00}% of the reads have a valid barcode.\n \
    Barcode correction will be reperformed with I1 as Forward instead of Reverse.\n")
        frac_bcs_found_for = correct_barcodes_from_fastq(
            R1 = R1,
            I1 = I1,
            R2 = R2,
            start_pos_bc=BC_START,
            bc_length_i=BC_LEN,
            nanoCT_singlecell_bc_whitelist=nanoCT_singlecell_bc_whitelist,
            corrected_bc_stats_tsv_filename=corrected_bc_stats_tsv_filename,
            reads_per_barcode_tsv_filename=reads_per_barcode_tsv_filename,
            max_hamming_dist=max_mismatches,
            rev_comp=not rev_comp)
        
        if frac_bcs_found_for < min_frac_bcs_to_find_default:
            sys.stderr.write(f"Warning: Only {frac_bcs_found_for * 100.00}% of the reads have a valid barcode (Forward mode).\n \
                                        Only {frac_bcs_found_rev * 100.00}% of the reads have a valid barcode (Reverse mode).\n \
                Check if you provided the correct barcode whitelist file.\n")
            sys.exit(1)
        else:
            sys.stdout.write(f"{frac_bcs_found_for * 100.00}% of the reads (Forward mode) had a valid barcode.\n")
    else:
        sys.stdout.write(f"{frac_bcs_found_rev * 100.00}% of the reads (Reverse mode) had a valid barcode.\n")

if __name__ == "__main__":
    main()